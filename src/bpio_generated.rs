// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod bpio {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_STATUS_REQUEST_TYPES: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_STATUS_REQUEST_TYPES: i8 = 8;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_STATUS_REQUEST_TYPES: [StatusRequestTypes; 9] = [
  StatusRequestTypes::All,
  StatusRequestTypes::Version,
  StatusRequestTypes::Mode,
  StatusRequestTypes::Pullup,
  StatusRequestTypes::PSU,
  StatusRequestTypes::ADC,
  StatusRequestTypes::IO,
  StatusRequestTypes::Disk,
  StatusRequestTypes::LED,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct StatusRequestTypes(pub i8);
#[allow(non_upper_case_globals)]
impl StatusRequestTypes {
  pub const All: Self = Self(0);
  pub const Version: Self = Self(1);
  pub const Mode: Self = Self(2);
  pub const Pullup: Self = Self(3);
  pub const PSU: Self = Self(4);
  pub const ADC: Self = Self(5);
  pub const IO: Self = Self(6);
  pub const Disk: Self = Self(7);
  pub const LED: Self = Self(8);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 8;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::All,
    Self::Version,
    Self::Mode,
    Self::Pullup,
    Self::PSU,
    Self::ADC,
    Self::IO,
    Self::Disk,
    Self::LED,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::All => Some("All"),
      Self::Version => Some("Version"),
      Self::Mode => Some("Mode"),
      Self::Pullup => Some("Pullup"),
      Self::PSU => Some("PSU"),
      Self::ADC => Some("ADC"),
      Self::IO => Some("IO"),
      Self::Disk => Some("Disk"),
      Self::LED => Some("LED"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for StatusRequestTypes {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for StatusRequestTypes {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for StatusRequestTypes {
    type Output = StatusRequestTypes;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for StatusRequestTypes {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for StatusRequestTypes {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for StatusRequestTypes {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_REQUEST_PACKET_CONTENTS: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_REQUEST_PACKET_CONTENTS: u8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_REQUEST_PACKET_CONTENTS: [RequestPacketContents; 4] = [
  RequestPacketContents::NONE,
  RequestPacketContents::StatusRequest,
  RequestPacketContents::ConfigurationRequest,
  RequestPacketContents::DataRequest,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct RequestPacketContents(pub u8);
#[allow(non_upper_case_globals)]
impl RequestPacketContents {
  pub const NONE: Self = Self(0);
  pub const StatusRequest: Self = Self(1);
  pub const ConfigurationRequest: Self = Self(2);
  pub const DataRequest: Self = Self(3);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::StatusRequest,
    Self::ConfigurationRequest,
    Self::DataRequest,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::StatusRequest => Some("StatusRequest"),
      Self::ConfigurationRequest => Some("ConfigurationRequest"),
      Self::DataRequest => Some("DataRequest"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for RequestPacketContents {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for RequestPacketContents {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for RequestPacketContents {
    type Output = RequestPacketContents;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for RequestPacketContents {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for RequestPacketContents {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for RequestPacketContents {}
pub struct RequestPacketContentsUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_RESPONSE_PACKET_CONTENTS: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_RESPONSE_PACKET_CONTENTS: u8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_RESPONSE_PACKET_CONTENTS: [ResponsePacketContents; 5] = [
  ResponsePacketContents::NONE,
  ResponsePacketContents::ErrorResponse,
  ResponsePacketContents::StatusResponse,
  ResponsePacketContents::ConfigurationResponse,
  ResponsePacketContents::DataResponse,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ResponsePacketContents(pub u8);
#[allow(non_upper_case_globals)]
impl ResponsePacketContents {
  pub const NONE: Self = Self(0);
  pub const ErrorResponse: Self = Self(1);
  pub const StatusResponse: Self = Self(2);
  pub const ConfigurationResponse: Self = Self(3);
  pub const DataResponse: Self = Self(4);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::ErrorResponse,
    Self::StatusResponse,
    Self::ConfigurationResponse,
    Self::DataResponse,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::ErrorResponse => Some("ErrorResponse"),
      Self::StatusResponse => Some("StatusResponse"),
      Self::ConfigurationResponse => Some("ConfigurationResponse"),
      Self::DataResponse => Some("DataResponse"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ResponsePacketContents {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ResponsePacketContents {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ResponsePacketContents {
    type Output = ResponsePacketContents;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ResponsePacketContents {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ResponsePacketContents {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ResponsePacketContents {}
pub struct ResponsePacketContentsUnionTableOffset {}

pub enum StatusRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct StatusRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StatusRequest<'a> {
  type Inner = StatusRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> StatusRequest<'a> {
  pub const VT_QUERY: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    StatusRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args StatusRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<StatusRequest<'bldr>> {
    let mut builder = StatusRequestBuilder::new(_fbb);
    if let Some(x) = args.query { builder.add_query(x); }
    builder.finish()
  }


  #[inline]
  pub fn query(&self) -> Option<flatbuffers::Vector<'a, StatusRequestTypes>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, StatusRequestTypes>>>(StatusRequest::VT_QUERY, None)}
  }
}

impl flatbuffers::Verifiable for StatusRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, StatusRequestTypes>>>("query", Self::VT_QUERY, false)?
     .finish();
    Ok(())
  }
}
pub struct StatusRequestArgs<'a> {
    pub query: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, StatusRequestTypes>>>,
}
impl<'a> Default for StatusRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    StatusRequestArgs {
      query: None,
    }
  }
}

pub struct StatusRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StatusRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_query(&mut self, query: flatbuffers::WIPOffset<flatbuffers::Vector<'b , StatusRequestTypes>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StatusRequest::VT_QUERY, query);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> StatusRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    StatusRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StatusRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for StatusRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("StatusRequest");
      ds.field("query", &self.query());
      ds.finish()
  }
}
pub enum StatusResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct StatusResponse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StatusResponse<'a> {
  type Inner = StatusResponse<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> StatusResponse<'a> {
  pub const VT_ERROR: flatbuffers::VOffsetT = 4;
  pub const VT_HARDWARE_VERSION_MAJOR: flatbuffers::VOffsetT = 6;
  pub const VT_HARDWARE_VERSION_MINOR: flatbuffers::VOffsetT = 8;
  pub const VT_FIRMWARE_VERSION_MAJOR: flatbuffers::VOffsetT = 10;
  pub const VT_FIRMWARE_VERSION_MINOR: flatbuffers::VOffsetT = 12;
  pub const VT_FIRMWARE_GIT_HASH: flatbuffers::VOffsetT = 14;
  pub const VT_FIRMWARE_DATE: flatbuffers::VOffsetT = 16;
  pub const VT_MODES_AVAILABLE: flatbuffers::VOffsetT = 18;
  pub const VT_MODE_CURRENT: flatbuffers::VOffsetT = 20;
  pub const VT_MODE_PIN_LABELS: flatbuffers::VOffsetT = 22;
  pub const VT_MODE_BITORDER_MSB: flatbuffers::VOffsetT = 24;
  pub const VT_PSU_ENABLED: flatbuffers::VOffsetT = 26;
  pub const VT_PSU_SET_MV: flatbuffers::VOffsetT = 28;
  pub const VT_PSU_SET_MA: flatbuffers::VOffsetT = 30;
  pub const VT_PSU_MEASURED_MV: flatbuffers::VOffsetT = 32;
  pub const VT_PSU_MEASURED_MA: flatbuffers::VOffsetT = 34;
  pub const VT_PSU_CURRENT_ERROR: flatbuffers::VOffsetT = 36;
  pub const VT_PULLUP_ENABLED: flatbuffers::VOffsetT = 38;
  pub const VT_PULLX_CONFIG: flatbuffers::VOffsetT = 40;
  pub const VT_ADC_MV: flatbuffers::VOffsetT = 42;
  pub const VT_IO_DIRECTION: flatbuffers::VOffsetT = 44;
  pub const VT_IO_VALUE: flatbuffers::VOffsetT = 46;
  pub const VT_DISK_SIZE_MB: flatbuffers::VOffsetT = 48;
  pub const VT_DISK_USED_MB: flatbuffers::VOffsetT = 50;
  pub const VT_LED_COUNT: flatbuffers::VOffsetT = 52;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    StatusResponse { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args StatusResponseArgs<'args>
  ) -> flatbuffers::WIPOffset<StatusResponse<'bldr>> {
    let mut builder = StatusResponseBuilder::new(_fbb);
    builder.add_disk_used_mb(args.disk_used_mb);
    builder.add_disk_size_mb(args.disk_size_mb);
    if let Some(x) = args.adc_mv { builder.add_adc_mv(x); }
    builder.add_pullx_config(args.pullx_config);
    builder.add_psu_measured_ma(args.psu_measured_ma);
    builder.add_psu_measured_mv(args.psu_measured_mv);
    builder.add_psu_set_ma(args.psu_set_ma);
    builder.add_psu_set_mv(args.psu_set_mv);
    if let Some(x) = args.mode_pin_labels { builder.add_mode_pin_labels(x); }
    if let Some(x) = args.mode_current { builder.add_mode_current(x); }
    if let Some(x) = args.modes_available { builder.add_modes_available(x); }
    if let Some(x) = args.firmware_date { builder.add_firmware_date(x); }
    if let Some(x) = args.firmware_git_hash { builder.add_firmware_git_hash(x); }
    if let Some(x) = args.error { builder.add_error(x); }
    builder.add_led_count(args.led_count);
    builder.add_io_value(args.io_value);
    builder.add_io_direction(args.io_direction);
    builder.add_pullup_enabled(args.pullup_enabled);
    builder.add_psu_current_error(args.psu_current_error);
    builder.add_psu_enabled(args.psu_enabled);
    builder.add_mode_bitorder_msb(args.mode_bitorder_msb);
    builder.add_firmware_version_minor(args.firmware_version_minor);
    builder.add_firmware_version_major(args.firmware_version_major);
    builder.add_hardware_version_minor(args.hardware_version_minor);
    builder.add_hardware_version_major(args.hardware_version_major);
    builder.finish()
  }


  #[inline]
  pub fn error(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StatusResponse::VT_ERROR, None)}
  }
  #[inline]
  pub fn hardware_version_major(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(StatusResponse::VT_HARDWARE_VERSION_MAJOR, Some(0)).unwrap()}
  }
  #[inline]
  pub fn hardware_version_minor(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(StatusResponse::VT_HARDWARE_VERSION_MINOR, Some(0)).unwrap()}
  }
  #[inline]
  pub fn firmware_version_major(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(StatusResponse::VT_FIRMWARE_VERSION_MAJOR, Some(0)).unwrap()}
  }
  #[inline]
  pub fn firmware_version_minor(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(StatusResponse::VT_FIRMWARE_VERSION_MINOR, Some(0)).unwrap()}
  }
  #[inline]
  pub fn firmware_git_hash(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StatusResponse::VT_FIRMWARE_GIT_HASH, None)}
  }
  #[inline]
  pub fn firmware_date(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StatusResponse::VT_FIRMWARE_DATE, None)}
  }
  #[inline]
  pub fn modes_available(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(StatusResponse::VT_MODES_AVAILABLE, None)}
  }
  #[inline]
  pub fn mode_current(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StatusResponse::VT_MODE_CURRENT, None)}
  }
  #[inline]
  pub fn mode_pin_labels(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(StatusResponse::VT_MODE_PIN_LABELS, None)}
  }
  #[inline]
  pub fn mode_bitorder_msb(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(StatusResponse::VT_MODE_BITORDER_MSB, Some(false)).unwrap()}
  }
  #[inline]
  pub fn psu_enabled(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(StatusResponse::VT_PSU_ENABLED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn psu_set_mv(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(StatusResponse::VT_PSU_SET_MV, Some(0)).unwrap()}
  }
  #[inline]
  pub fn psu_set_ma(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(StatusResponse::VT_PSU_SET_MA, Some(0)).unwrap()}
  }
  #[inline]
  pub fn psu_measured_mv(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(StatusResponse::VT_PSU_MEASURED_MV, Some(0)).unwrap()}
  }
  #[inline]
  pub fn psu_measured_ma(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(StatusResponse::VT_PSU_MEASURED_MA, Some(0)).unwrap()}
  }
  #[inline]
  pub fn psu_current_error(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(StatusResponse::VT_PSU_CURRENT_ERROR, Some(false)).unwrap()}
  }
  #[inline]
  pub fn pullup_enabled(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(StatusResponse::VT_PULLUP_ENABLED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn pullx_config(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(StatusResponse::VT_PULLX_CONFIG, Some(0)).unwrap()}
  }
  #[inline]
  pub fn adc_mv(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(StatusResponse::VT_ADC_MV, None)}
  }
  #[inline]
  pub fn io_direction(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(StatusResponse::VT_IO_DIRECTION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn io_value(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(StatusResponse::VT_IO_VALUE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn disk_size_mb(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(StatusResponse::VT_DISK_SIZE_MB, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn disk_used_mb(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(StatusResponse::VT_DISK_USED_MB, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn led_count(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(StatusResponse::VT_LED_COUNT, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for StatusResponse<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("error", Self::VT_ERROR, false)?
     .visit_field::<u8>("hardware_version_major", Self::VT_HARDWARE_VERSION_MAJOR, false)?
     .visit_field::<u8>("hardware_version_minor", Self::VT_HARDWARE_VERSION_MINOR, false)?
     .visit_field::<u8>("firmware_version_major", Self::VT_FIRMWARE_VERSION_MAJOR, false)?
     .visit_field::<u8>("firmware_version_minor", Self::VT_FIRMWARE_VERSION_MINOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("firmware_git_hash", Self::VT_FIRMWARE_GIT_HASH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("firmware_date", Self::VT_FIRMWARE_DATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("modes_available", Self::VT_MODES_AVAILABLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("mode_current", Self::VT_MODE_CURRENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("mode_pin_labels", Self::VT_MODE_PIN_LABELS, false)?
     .visit_field::<bool>("mode_bitorder_msb", Self::VT_MODE_BITORDER_MSB, false)?
     .visit_field::<bool>("psu_enabled", Self::VT_PSU_ENABLED, false)?
     .visit_field::<u32>("psu_set_mv", Self::VT_PSU_SET_MV, false)?
     .visit_field::<u32>("psu_set_ma", Self::VT_PSU_SET_MA, false)?
     .visit_field::<u32>("psu_measured_mv", Self::VT_PSU_MEASURED_MV, false)?
     .visit_field::<u32>("psu_measured_ma", Self::VT_PSU_MEASURED_MA, false)?
     .visit_field::<bool>("psu_current_error", Self::VT_PSU_CURRENT_ERROR, false)?
     .visit_field::<bool>("pullup_enabled", Self::VT_PULLUP_ENABLED, false)?
     .visit_field::<u32>("pullx_config", Self::VT_PULLX_CONFIG, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>("adc_mv", Self::VT_ADC_MV, false)?
     .visit_field::<u8>("io_direction", Self::VT_IO_DIRECTION, false)?
     .visit_field::<u8>("io_value", Self::VT_IO_VALUE, false)?
     .visit_field::<f32>("disk_size_mb", Self::VT_DISK_SIZE_MB, false)?
     .visit_field::<f32>("disk_used_mb", Self::VT_DISK_USED_MB, false)?
     .visit_field::<u8>("led_count", Self::VT_LED_COUNT, false)?
     .finish();
    Ok(())
  }
}
pub struct StatusResponseArgs<'a> {
    pub error: Option<flatbuffers::WIPOffset<&'a str>>,
    pub hardware_version_major: u8,
    pub hardware_version_minor: u8,
    pub firmware_version_major: u8,
    pub firmware_version_minor: u8,
    pub firmware_git_hash: Option<flatbuffers::WIPOffset<&'a str>>,
    pub firmware_date: Option<flatbuffers::WIPOffset<&'a str>>,
    pub modes_available: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub mode_current: Option<flatbuffers::WIPOffset<&'a str>>,
    pub mode_pin_labels: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub mode_bitorder_msb: bool,
    pub psu_enabled: bool,
    pub psu_set_mv: u32,
    pub psu_set_ma: u32,
    pub psu_measured_mv: u32,
    pub psu_measured_ma: u32,
    pub psu_current_error: bool,
    pub pullup_enabled: bool,
    pub pullx_config: u32,
    pub adc_mv: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub io_direction: u8,
    pub io_value: u8,
    pub disk_size_mb: f32,
    pub disk_used_mb: f32,
    pub led_count: u8,
}
impl<'a> Default for StatusResponseArgs<'a> {
  #[inline]
  fn default() -> Self {
    StatusResponseArgs {
      error: None,
      hardware_version_major: 0,
      hardware_version_minor: 0,
      firmware_version_major: 0,
      firmware_version_minor: 0,
      firmware_git_hash: None,
      firmware_date: None,
      modes_available: None,
      mode_current: None,
      mode_pin_labels: None,
      mode_bitorder_msb: false,
      psu_enabled: false,
      psu_set_mv: 0,
      psu_set_ma: 0,
      psu_measured_mv: 0,
      psu_measured_ma: 0,
      psu_current_error: false,
      pullup_enabled: false,
      pullx_config: 0,
      adc_mv: None,
      io_direction: 0,
      io_value: 0,
      disk_size_mb: 0.0,
      disk_used_mb: 0.0,
      led_count: 0,
    }
  }
}

pub struct StatusResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StatusResponseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_error(&mut self, error: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StatusResponse::VT_ERROR, error);
  }
  #[inline]
  pub fn add_hardware_version_major(&mut self, hardware_version_major: u8) {
    self.fbb_.push_slot::<u8>(StatusResponse::VT_HARDWARE_VERSION_MAJOR, hardware_version_major, 0);
  }
  #[inline]
  pub fn add_hardware_version_minor(&mut self, hardware_version_minor: u8) {
    self.fbb_.push_slot::<u8>(StatusResponse::VT_HARDWARE_VERSION_MINOR, hardware_version_minor, 0);
  }
  #[inline]
  pub fn add_firmware_version_major(&mut self, firmware_version_major: u8) {
    self.fbb_.push_slot::<u8>(StatusResponse::VT_FIRMWARE_VERSION_MAJOR, firmware_version_major, 0);
  }
  #[inline]
  pub fn add_firmware_version_minor(&mut self, firmware_version_minor: u8) {
    self.fbb_.push_slot::<u8>(StatusResponse::VT_FIRMWARE_VERSION_MINOR, firmware_version_minor, 0);
  }
  #[inline]
  pub fn add_firmware_git_hash(&mut self, firmware_git_hash: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StatusResponse::VT_FIRMWARE_GIT_HASH, firmware_git_hash);
  }
  #[inline]
  pub fn add_firmware_date(&mut self, firmware_date: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StatusResponse::VT_FIRMWARE_DATE, firmware_date);
  }
  #[inline]
  pub fn add_modes_available(&mut self, modes_available: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StatusResponse::VT_MODES_AVAILABLE, modes_available);
  }
  #[inline]
  pub fn add_mode_current(&mut self, mode_current: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StatusResponse::VT_MODE_CURRENT, mode_current);
  }
  #[inline]
  pub fn add_mode_pin_labels(&mut self, mode_pin_labels: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StatusResponse::VT_MODE_PIN_LABELS, mode_pin_labels);
  }
  #[inline]
  pub fn add_mode_bitorder_msb(&mut self, mode_bitorder_msb: bool) {
    self.fbb_.push_slot::<bool>(StatusResponse::VT_MODE_BITORDER_MSB, mode_bitorder_msb, false);
  }
  #[inline]
  pub fn add_psu_enabled(&mut self, psu_enabled: bool) {
    self.fbb_.push_slot::<bool>(StatusResponse::VT_PSU_ENABLED, psu_enabled, false);
  }
  #[inline]
  pub fn add_psu_set_mv(&mut self, psu_set_mv: u32) {
    self.fbb_.push_slot::<u32>(StatusResponse::VT_PSU_SET_MV, psu_set_mv, 0);
  }
  #[inline]
  pub fn add_psu_set_ma(&mut self, psu_set_ma: u32) {
    self.fbb_.push_slot::<u32>(StatusResponse::VT_PSU_SET_MA, psu_set_ma, 0);
  }
  #[inline]
  pub fn add_psu_measured_mv(&mut self, psu_measured_mv: u32) {
    self.fbb_.push_slot::<u32>(StatusResponse::VT_PSU_MEASURED_MV, psu_measured_mv, 0);
  }
  #[inline]
  pub fn add_psu_measured_ma(&mut self, psu_measured_ma: u32) {
    self.fbb_.push_slot::<u32>(StatusResponse::VT_PSU_MEASURED_MA, psu_measured_ma, 0);
  }
  #[inline]
  pub fn add_psu_current_error(&mut self, psu_current_error: bool) {
    self.fbb_.push_slot::<bool>(StatusResponse::VT_PSU_CURRENT_ERROR, psu_current_error, false);
  }
  #[inline]
  pub fn add_pullup_enabled(&mut self, pullup_enabled: bool) {
    self.fbb_.push_slot::<bool>(StatusResponse::VT_PULLUP_ENABLED, pullup_enabled, false);
  }
  #[inline]
  pub fn add_pullx_config(&mut self, pullx_config: u32) {
    self.fbb_.push_slot::<u32>(StatusResponse::VT_PULLX_CONFIG, pullx_config, 0);
  }
  #[inline]
  pub fn add_adc_mv(&mut self, adc_mv: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StatusResponse::VT_ADC_MV, adc_mv);
  }
  #[inline]
  pub fn add_io_direction(&mut self, io_direction: u8) {
    self.fbb_.push_slot::<u8>(StatusResponse::VT_IO_DIRECTION, io_direction, 0);
  }
  #[inline]
  pub fn add_io_value(&mut self, io_value: u8) {
    self.fbb_.push_slot::<u8>(StatusResponse::VT_IO_VALUE, io_value, 0);
  }
  #[inline]
  pub fn add_disk_size_mb(&mut self, disk_size_mb: f32) {
    self.fbb_.push_slot::<f32>(StatusResponse::VT_DISK_SIZE_MB, disk_size_mb, 0.0);
  }
  #[inline]
  pub fn add_disk_used_mb(&mut self, disk_used_mb: f32) {
    self.fbb_.push_slot::<f32>(StatusResponse::VT_DISK_USED_MB, disk_used_mb, 0.0);
  }
  #[inline]
  pub fn add_led_count(&mut self, led_count: u8) {
    self.fbb_.push_slot::<u8>(StatusResponse::VT_LED_COUNT, led_count, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> StatusResponseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    StatusResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StatusResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for StatusResponse<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("StatusResponse");
      ds.field("error", &self.error());
      ds.field("hardware_version_major", &self.hardware_version_major());
      ds.field("hardware_version_minor", &self.hardware_version_minor());
      ds.field("firmware_version_major", &self.firmware_version_major());
      ds.field("firmware_version_minor", &self.firmware_version_minor());
      ds.field("firmware_git_hash", &self.firmware_git_hash());
      ds.field("firmware_date", &self.firmware_date());
      ds.field("modes_available", &self.modes_available());
      ds.field("mode_current", &self.mode_current());
      ds.field("mode_pin_labels", &self.mode_pin_labels());
      ds.field("mode_bitorder_msb", &self.mode_bitorder_msb());
      ds.field("psu_enabled", &self.psu_enabled());
      ds.field("psu_set_mv", &self.psu_set_mv());
      ds.field("psu_set_ma", &self.psu_set_ma());
      ds.field("psu_measured_mv", &self.psu_measured_mv());
      ds.field("psu_measured_ma", &self.psu_measured_ma());
      ds.field("psu_current_error", &self.psu_current_error());
      ds.field("pullup_enabled", &self.pullup_enabled());
      ds.field("pullx_config", &self.pullx_config());
      ds.field("adc_mv", &self.adc_mv());
      ds.field("io_direction", &self.io_direction());
      ds.field("io_value", &self.io_value());
      ds.field("disk_size_mb", &self.disk_size_mb());
      ds.field("disk_used_mb", &self.disk_used_mb());
      ds.field("led_count", &self.led_count());
      ds.finish()
  }
}
pub enum ModeConfigurationOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ModeConfiguration<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ModeConfiguration<'a> {
  type Inner = ModeConfiguration<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ModeConfiguration<'a> {
  pub const VT_SPEED: flatbuffers::VOffsetT = 4;
  pub const VT_DATA_BITS: flatbuffers::VOffsetT = 6;
  pub const VT_PARITY: flatbuffers::VOffsetT = 8;
  pub const VT_STOP_BITS: flatbuffers::VOffsetT = 10;
  pub const VT_FLOW_CONTROL: flatbuffers::VOffsetT = 12;
  pub const VT_SIGNAL_INVERSION: flatbuffers::VOffsetT = 14;
  pub const VT_CLOCK_STRETCH: flatbuffers::VOffsetT = 16;
  pub const VT_CLOCK_POLARITY: flatbuffers::VOffsetT = 18;
  pub const VT_CLOCK_PHASE: flatbuffers::VOffsetT = 20;
  pub const VT_CHIP_SELECT_IDLE: flatbuffers::VOffsetT = 22;
  pub const VT_SUBMODE: flatbuffers::VOffsetT = 24;
  pub const VT_TX_MODULATION: flatbuffers::VOffsetT = 26;
  pub const VT_RX_SENSOR: flatbuffers::VOffsetT = 28;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ModeConfiguration { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ModeConfigurationArgs
  ) -> flatbuffers::WIPOffset<ModeConfiguration<'bldr>> {
    let mut builder = ModeConfigurationBuilder::new(_fbb);
    builder.add_tx_modulation(args.tx_modulation);
    builder.add_speed(args.speed);
    builder.add_rx_sensor(args.rx_sensor);
    builder.add_submode(args.submode);
    builder.add_chip_select_idle(args.chip_select_idle);
    builder.add_clock_phase(args.clock_phase);
    builder.add_clock_polarity(args.clock_polarity);
    builder.add_clock_stretch(args.clock_stretch);
    builder.add_signal_inversion(args.signal_inversion);
    builder.add_flow_control(args.flow_control);
    builder.add_stop_bits(args.stop_bits);
    builder.add_parity(args.parity);
    builder.add_data_bits(args.data_bits);
    builder.finish()
  }


  #[inline]
  pub fn speed(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(ModeConfiguration::VT_SPEED, Some(20000)).unwrap()}
  }
  #[inline]
  pub fn data_bits(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(ModeConfiguration::VT_DATA_BITS, Some(8)).unwrap()}
  }
  #[inline]
  pub fn parity(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ModeConfiguration::VT_PARITY, Some(false)).unwrap()}
  }
  #[inline]
  pub fn stop_bits(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(ModeConfiguration::VT_STOP_BITS, Some(1)).unwrap()}
  }
  #[inline]
  pub fn flow_control(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ModeConfiguration::VT_FLOW_CONTROL, Some(false)).unwrap()}
  }
  #[inline]
  pub fn signal_inversion(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ModeConfiguration::VT_SIGNAL_INVERSION, Some(false)).unwrap()}
  }
  #[inline]
  pub fn clock_stretch(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ModeConfiguration::VT_CLOCK_STRETCH, Some(false)).unwrap()}
  }
  #[inline]
  pub fn clock_polarity(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ModeConfiguration::VT_CLOCK_POLARITY, Some(false)).unwrap()}
  }
  #[inline]
  pub fn clock_phase(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ModeConfiguration::VT_CLOCK_PHASE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn chip_select_idle(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ModeConfiguration::VT_CHIP_SELECT_IDLE, Some(true)).unwrap()}
  }
  #[inline]
  pub fn submode(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(ModeConfiguration::VT_SUBMODE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn tx_modulation(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(ModeConfiguration::VT_TX_MODULATION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn rx_sensor(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(ModeConfiguration::VT_RX_SENSOR, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ModeConfiguration<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("speed", Self::VT_SPEED, false)?
     .visit_field::<u8>("data_bits", Self::VT_DATA_BITS, false)?
     .visit_field::<bool>("parity", Self::VT_PARITY, false)?
     .visit_field::<u8>("stop_bits", Self::VT_STOP_BITS, false)?
     .visit_field::<bool>("flow_control", Self::VT_FLOW_CONTROL, false)?
     .visit_field::<bool>("signal_inversion", Self::VT_SIGNAL_INVERSION, false)?
     .visit_field::<bool>("clock_stretch", Self::VT_CLOCK_STRETCH, false)?
     .visit_field::<bool>("clock_polarity", Self::VT_CLOCK_POLARITY, false)?
     .visit_field::<bool>("clock_phase", Self::VT_CLOCK_PHASE, false)?
     .visit_field::<bool>("chip_select_idle", Self::VT_CHIP_SELECT_IDLE, false)?
     .visit_field::<u8>("submode", Self::VT_SUBMODE, false)?
     .visit_field::<u32>("tx_modulation", Self::VT_TX_MODULATION, false)?
     .visit_field::<u8>("rx_sensor", Self::VT_RX_SENSOR, false)?
     .finish();
    Ok(())
  }
}
pub struct ModeConfigurationArgs {
    pub speed: u32,
    pub data_bits: u8,
    pub parity: bool,
    pub stop_bits: u8,
    pub flow_control: bool,
    pub signal_inversion: bool,
    pub clock_stretch: bool,
    pub clock_polarity: bool,
    pub clock_phase: bool,
    pub chip_select_idle: bool,
    pub submode: u8,
    pub tx_modulation: u32,
    pub rx_sensor: u8,
}
impl<'a> Default for ModeConfigurationArgs {
  #[inline]
  fn default() -> Self {
    ModeConfigurationArgs {
      speed: 20000,
      data_bits: 8,
      parity: false,
      stop_bits: 1,
      flow_control: false,
      signal_inversion: false,
      clock_stretch: false,
      clock_polarity: false,
      clock_phase: false,
      chip_select_idle: true,
      submode: 0,
      tx_modulation: 0,
      rx_sensor: 0,
    }
  }
}

pub struct ModeConfigurationBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ModeConfigurationBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_speed(&mut self, speed: u32) {
    self.fbb_.push_slot::<u32>(ModeConfiguration::VT_SPEED, speed, 20000);
  }
  #[inline]
  pub fn add_data_bits(&mut self, data_bits: u8) {
    self.fbb_.push_slot::<u8>(ModeConfiguration::VT_DATA_BITS, data_bits, 8);
  }
  #[inline]
  pub fn add_parity(&mut self, parity: bool) {
    self.fbb_.push_slot::<bool>(ModeConfiguration::VT_PARITY, parity, false);
  }
  #[inline]
  pub fn add_stop_bits(&mut self, stop_bits: u8) {
    self.fbb_.push_slot::<u8>(ModeConfiguration::VT_STOP_BITS, stop_bits, 1);
  }
  #[inline]
  pub fn add_flow_control(&mut self, flow_control: bool) {
    self.fbb_.push_slot::<bool>(ModeConfiguration::VT_FLOW_CONTROL, flow_control, false);
  }
  #[inline]
  pub fn add_signal_inversion(&mut self, signal_inversion: bool) {
    self.fbb_.push_slot::<bool>(ModeConfiguration::VT_SIGNAL_INVERSION, signal_inversion, false);
  }
  #[inline]
  pub fn add_clock_stretch(&mut self, clock_stretch: bool) {
    self.fbb_.push_slot::<bool>(ModeConfiguration::VT_CLOCK_STRETCH, clock_stretch, false);
  }
  #[inline]
  pub fn add_clock_polarity(&mut self, clock_polarity: bool) {
    self.fbb_.push_slot::<bool>(ModeConfiguration::VT_CLOCK_POLARITY, clock_polarity, false);
  }
  #[inline]
  pub fn add_clock_phase(&mut self, clock_phase: bool) {
    self.fbb_.push_slot::<bool>(ModeConfiguration::VT_CLOCK_PHASE, clock_phase, false);
  }
  #[inline]
  pub fn add_chip_select_idle(&mut self, chip_select_idle: bool) {
    self.fbb_.push_slot::<bool>(ModeConfiguration::VT_CHIP_SELECT_IDLE, chip_select_idle, true);
  }
  #[inline]
  pub fn add_submode(&mut self, submode: u8) {
    self.fbb_.push_slot::<u8>(ModeConfiguration::VT_SUBMODE, submode, 0);
  }
  #[inline]
  pub fn add_tx_modulation(&mut self, tx_modulation: u32) {
    self.fbb_.push_slot::<u32>(ModeConfiguration::VT_TX_MODULATION, tx_modulation, 0);
  }
  #[inline]
  pub fn add_rx_sensor(&mut self, rx_sensor: u8) {
    self.fbb_.push_slot::<u8>(ModeConfiguration::VT_RX_SENSOR, rx_sensor, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ModeConfigurationBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ModeConfigurationBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ModeConfiguration<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ModeConfiguration<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ModeConfiguration");
      ds.field("speed", &self.speed());
      ds.field("data_bits", &self.data_bits());
      ds.field("parity", &self.parity());
      ds.field("stop_bits", &self.stop_bits());
      ds.field("flow_control", &self.flow_control());
      ds.field("signal_inversion", &self.signal_inversion());
      ds.field("clock_stretch", &self.clock_stretch());
      ds.field("clock_polarity", &self.clock_polarity());
      ds.field("clock_phase", &self.clock_phase());
      ds.field("chip_select_idle", &self.chip_select_idle());
      ds.field("submode", &self.submode());
      ds.field("tx_modulation", &self.tx_modulation());
      ds.field("rx_sensor", &self.rx_sensor());
      ds.finish()
  }
}
pub enum ConfigurationRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ConfigurationRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ConfigurationRequest<'a> {
  type Inner = ConfigurationRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ConfigurationRequest<'a> {
  pub const VT_MODE: flatbuffers::VOffsetT = 4;
  pub const VT_MODE_CONFIGURATION: flatbuffers::VOffsetT = 6;
  pub const VT_MODE_BITORDER_MSB: flatbuffers::VOffsetT = 8;
  pub const VT_MODE_BITORDER_LSB: flatbuffers::VOffsetT = 10;
  pub const VT_PSU_DISABLE: flatbuffers::VOffsetT = 12;
  pub const VT_PSU_ENABLE: flatbuffers::VOffsetT = 14;
  pub const VT_PSU_SET_MV: flatbuffers::VOffsetT = 16;
  pub const VT_PSU_SET_MA: flatbuffers::VOffsetT = 18;
  pub const VT_PULLUP_DISABLE: flatbuffers::VOffsetT = 20;
  pub const VT_PULLUP_ENABLE: flatbuffers::VOffsetT = 22;
  pub const VT_PULLX_CONFIG: flatbuffers::VOffsetT = 24;
  pub const VT_IO_DIRECTION_MASK: flatbuffers::VOffsetT = 26;
  pub const VT_IO_DIRECTION: flatbuffers::VOffsetT = 28;
  pub const VT_IO_VALUE_MASK: flatbuffers::VOffsetT = 30;
  pub const VT_IO_VALUE: flatbuffers::VOffsetT = 32;
  pub const VT_LED_RESUME: flatbuffers::VOffsetT = 34;
  pub const VT_LED_COLOR: flatbuffers::VOffsetT = 36;
  pub const VT_PRINT_STRING: flatbuffers::VOffsetT = 38;
  pub const VT_HARDWARE_BOOTLOADER: flatbuffers::VOffsetT = 40;
  pub const VT_HARDWARE_RESET: flatbuffers::VOffsetT = 42;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ConfigurationRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ConfigurationRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<ConfigurationRequest<'bldr>> {
    let mut builder = ConfigurationRequestBuilder::new(_fbb);
    if let Some(x) = args.print_string { builder.add_print_string(x); }
    if let Some(x) = args.led_color { builder.add_led_color(x); }
    builder.add_pullx_config(args.pullx_config);
    builder.add_psu_set_mv(args.psu_set_mv);
    if let Some(x) = args.mode_configuration { builder.add_mode_configuration(x); }
    if let Some(x) = args.mode { builder.add_mode(x); }
    builder.add_psu_set_ma(args.psu_set_ma);
    builder.add_hardware_reset(args.hardware_reset);
    builder.add_hardware_bootloader(args.hardware_bootloader);
    builder.add_led_resume(args.led_resume);
    builder.add_io_value(args.io_value);
    builder.add_io_value_mask(args.io_value_mask);
    builder.add_io_direction(args.io_direction);
    builder.add_io_direction_mask(args.io_direction_mask);
    builder.add_pullup_enable(args.pullup_enable);
    builder.add_pullup_disable(args.pullup_disable);
    builder.add_psu_enable(args.psu_enable);
    builder.add_psu_disable(args.psu_disable);
    builder.add_mode_bitorder_lsb(args.mode_bitorder_lsb);
    builder.add_mode_bitorder_msb(args.mode_bitorder_msb);
    builder.finish()
  }


  #[inline]
  pub fn mode(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ConfigurationRequest::VT_MODE, None)}
  }
  #[inline]
  pub fn mode_configuration(&self) -> Option<ModeConfiguration<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ModeConfiguration>>(ConfigurationRequest::VT_MODE_CONFIGURATION, None)}
  }
  #[inline]
  pub fn mode_bitorder_msb(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ConfigurationRequest::VT_MODE_BITORDER_MSB, Some(false)).unwrap()}
  }
  #[inline]
  pub fn mode_bitorder_lsb(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ConfigurationRequest::VT_MODE_BITORDER_LSB, Some(false)).unwrap()}
  }
  #[inline]
  pub fn psu_disable(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ConfigurationRequest::VT_PSU_DISABLE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn psu_enable(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ConfigurationRequest::VT_PSU_ENABLE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn psu_set_mv(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(ConfigurationRequest::VT_PSU_SET_MV, Some(0)).unwrap()}
  }
  #[inline]
  pub fn psu_set_ma(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(ConfigurationRequest::VT_PSU_SET_MA, Some(300)).unwrap()}
  }
  #[inline]
  pub fn pullup_disable(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ConfigurationRequest::VT_PULLUP_DISABLE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn pullup_enable(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ConfigurationRequest::VT_PULLUP_ENABLE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn pullx_config(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(ConfigurationRequest::VT_PULLX_CONFIG, Some(0)).unwrap()}
  }
  #[inline]
  pub fn io_direction_mask(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(ConfigurationRequest::VT_IO_DIRECTION_MASK, Some(0)).unwrap()}
  }
  #[inline]
  pub fn io_direction(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(ConfigurationRequest::VT_IO_DIRECTION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn io_value_mask(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(ConfigurationRequest::VT_IO_VALUE_MASK, Some(0)).unwrap()}
  }
  #[inline]
  pub fn io_value(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(ConfigurationRequest::VT_IO_VALUE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn led_resume(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ConfigurationRequest::VT_LED_RESUME, Some(false)).unwrap()}
  }
  #[inline]
  pub fn led_color(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(ConfigurationRequest::VT_LED_COLOR, None)}
  }
  #[inline]
  pub fn print_string(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ConfigurationRequest::VT_PRINT_STRING, None)}
  }
  #[inline]
  pub fn hardware_bootloader(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ConfigurationRequest::VT_HARDWARE_BOOTLOADER, Some(false)).unwrap()}
  }
  #[inline]
  pub fn hardware_reset(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ConfigurationRequest::VT_HARDWARE_RESET, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ConfigurationRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("mode", Self::VT_MODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ModeConfiguration>>("mode_configuration", Self::VT_MODE_CONFIGURATION, false)?
     .visit_field::<bool>("mode_bitorder_msb", Self::VT_MODE_BITORDER_MSB, false)?
     .visit_field::<bool>("mode_bitorder_lsb", Self::VT_MODE_BITORDER_LSB, false)?
     .visit_field::<bool>("psu_disable", Self::VT_PSU_DISABLE, false)?
     .visit_field::<bool>("psu_enable", Self::VT_PSU_ENABLE, false)?
     .visit_field::<u32>("psu_set_mv", Self::VT_PSU_SET_MV, false)?
     .visit_field::<u16>("psu_set_ma", Self::VT_PSU_SET_MA, false)?
     .visit_field::<bool>("pullup_disable", Self::VT_PULLUP_DISABLE, false)?
     .visit_field::<bool>("pullup_enable", Self::VT_PULLUP_ENABLE, false)?
     .visit_field::<u32>("pullx_config", Self::VT_PULLX_CONFIG, false)?
     .visit_field::<u8>("io_direction_mask", Self::VT_IO_DIRECTION_MASK, false)?
     .visit_field::<u8>("io_direction", Self::VT_IO_DIRECTION, false)?
     .visit_field::<u8>("io_value_mask", Self::VT_IO_VALUE_MASK, false)?
     .visit_field::<u8>("io_value", Self::VT_IO_VALUE, false)?
     .visit_field::<bool>("led_resume", Self::VT_LED_RESUME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>("led_color", Self::VT_LED_COLOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("print_string", Self::VT_PRINT_STRING, false)?
     .visit_field::<bool>("hardware_bootloader", Self::VT_HARDWARE_BOOTLOADER, false)?
     .visit_field::<bool>("hardware_reset", Self::VT_HARDWARE_RESET, false)?
     .finish();
    Ok(())
  }
}
pub struct ConfigurationRequestArgs<'a> {
    pub mode: Option<flatbuffers::WIPOffset<&'a str>>,
    pub mode_configuration: Option<flatbuffers::WIPOffset<ModeConfiguration<'a>>>,
    pub mode_bitorder_msb: bool,
    pub mode_bitorder_lsb: bool,
    pub psu_disable: bool,
    pub psu_enable: bool,
    pub psu_set_mv: u32,
    pub psu_set_ma: u16,
    pub pullup_disable: bool,
    pub pullup_enable: bool,
    pub pullx_config: u32,
    pub io_direction_mask: u8,
    pub io_direction: u8,
    pub io_value_mask: u8,
    pub io_value: u8,
    pub led_resume: bool,
    pub led_color: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub print_string: Option<flatbuffers::WIPOffset<&'a str>>,
    pub hardware_bootloader: bool,
    pub hardware_reset: bool,
}
impl<'a> Default for ConfigurationRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    ConfigurationRequestArgs {
      mode: None,
      mode_configuration: None,
      mode_bitorder_msb: false,
      mode_bitorder_lsb: false,
      psu_disable: false,
      psu_enable: false,
      psu_set_mv: 0,
      psu_set_ma: 300,
      pullup_disable: false,
      pullup_enable: false,
      pullx_config: 0,
      io_direction_mask: 0,
      io_direction: 0,
      io_value_mask: 0,
      io_value: 0,
      led_resume: false,
      led_color: None,
      print_string: None,
      hardware_bootloader: false,
      hardware_reset: false,
    }
  }
}

pub struct ConfigurationRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ConfigurationRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_mode(&mut self, mode: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ConfigurationRequest::VT_MODE, mode);
  }
  #[inline]
  pub fn add_mode_configuration(&mut self, mode_configuration: flatbuffers::WIPOffset<ModeConfiguration<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ModeConfiguration>>(ConfigurationRequest::VT_MODE_CONFIGURATION, mode_configuration);
  }
  #[inline]
  pub fn add_mode_bitorder_msb(&mut self, mode_bitorder_msb: bool) {
    self.fbb_.push_slot::<bool>(ConfigurationRequest::VT_MODE_BITORDER_MSB, mode_bitorder_msb, false);
  }
  #[inline]
  pub fn add_mode_bitorder_lsb(&mut self, mode_bitorder_lsb: bool) {
    self.fbb_.push_slot::<bool>(ConfigurationRequest::VT_MODE_BITORDER_LSB, mode_bitorder_lsb, false);
  }
  #[inline]
  pub fn add_psu_disable(&mut self, psu_disable: bool) {
    self.fbb_.push_slot::<bool>(ConfigurationRequest::VT_PSU_DISABLE, psu_disable, false);
  }
  #[inline]
  pub fn add_psu_enable(&mut self, psu_enable: bool) {
    self.fbb_.push_slot::<bool>(ConfigurationRequest::VT_PSU_ENABLE, psu_enable, false);
  }
  #[inline]
  pub fn add_psu_set_mv(&mut self, psu_set_mv: u32) {
    self.fbb_.push_slot::<u32>(ConfigurationRequest::VT_PSU_SET_MV, psu_set_mv, 0);
  }
  #[inline]
  pub fn add_psu_set_ma(&mut self, psu_set_ma: u16) {
    self.fbb_.push_slot::<u16>(ConfigurationRequest::VT_PSU_SET_MA, psu_set_ma, 300);
  }
  #[inline]
  pub fn add_pullup_disable(&mut self, pullup_disable: bool) {
    self.fbb_.push_slot::<bool>(ConfigurationRequest::VT_PULLUP_DISABLE, pullup_disable, false);
  }
  #[inline]
  pub fn add_pullup_enable(&mut self, pullup_enable: bool) {
    self.fbb_.push_slot::<bool>(ConfigurationRequest::VT_PULLUP_ENABLE, pullup_enable, false);
  }
  #[inline]
  pub fn add_pullx_config(&mut self, pullx_config: u32) {
    self.fbb_.push_slot::<u32>(ConfigurationRequest::VT_PULLX_CONFIG, pullx_config, 0);
  }
  #[inline]
  pub fn add_io_direction_mask(&mut self, io_direction_mask: u8) {
    self.fbb_.push_slot::<u8>(ConfigurationRequest::VT_IO_DIRECTION_MASK, io_direction_mask, 0);
  }
  #[inline]
  pub fn add_io_direction(&mut self, io_direction: u8) {
    self.fbb_.push_slot::<u8>(ConfigurationRequest::VT_IO_DIRECTION, io_direction, 0);
  }
  #[inline]
  pub fn add_io_value_mask(&mut self, io_value_mask: u8) {
    self.fbb_.push_slot::<u8>(ConfigurationRequest::VT_IO_VALUE_MASK, io_value_mask, 0);
  }
  #[inline]
  pub fn add_io_value(&mut self, io_value: u8) {
    self.fbb_.push_slot::<u8>(ConfigurationRequest::VT_IO_VALUE, io_value, 0);
  }
  #[inline]
  pub fn add_led_resume(&mut self, led_resume: bool) {
    self.fbb_.push_slot::<bool>(ConfigurationRequest::VT_LED_RESUME, led_resume, false);
  }
  #[inline]
  pub fn add_led_color(&mut self, led_color: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ConfigurationRequest::VT_LED_COLOR, led_color);
  }
  #[inline]
  pub fn add_print_string(&mut self, print_string: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ConfigurationRequest::VT_PRINT_STRING, print_string);
  }
  #[inline]
  pub fn add_hardware_bootloader(&mut self, hardware_bootloader: bool) {
    self.fbb_.push_slot::<bool>(ConfigurationRequest::VT_HARDWARE_BOOTLOADER, hardware_bootloader, false);
  }
  #[inline]
  pub fn add_hardware_reset(&mut self, hardware_reset: bool) {
    self.fbb_.push_slot::<bool>(ConfigurationRequest::VT_HARDWARE_RESET, hardware_reset, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ConfigurationRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ConfigurationRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ConfigurationRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ConfigurationRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ConfigurationRequest");
      ds.field("mode", &self.mode());
      ds.field("mode_configuration", &self.mode_configuration());
      ds.field("mode_bitorder_msb", &self.mode_bitorder_msb());
      ds.field("mode_bitorder_lsb", &self.mode_bitorder_lsb());
      ds.field("psu_disable", &self.psu_disable());
      ds.field("psu_enable", &self.psu_enable());
      ds.field("psu_set_mv", &self.psu_set_mv());
      ds.field("psu_set_ma", &self.psu_set_ma());
      ds.field("pullup_disable", &self.pullup_disable());
      ds.field("pullup_enable", &self.pullup_enable());
      ds.field("pullx_config", &self.pullx_config());
      ds.field("io_direction_mask", &self.io_direction_mask());
      ds.field("io_direction", &self.io_direction());
      ds.field("io_value_mask", &self.io_value_mask());
      ds.field("io_value", &self.io_value());
      ds.field("led_resume", &self.led_resume());
      ds.field("led_color", &self.led_color());
      ds.field("print_string", &self.print_string());
      ds.field("hardware_bootloader", &self.hardware_bootloader());
      ds.field("hardware_reset", &self.hardware_reset());
      ds.finish()
  }
}
pub enum ConfigurationResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ConfigurationResponse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ConfigurationResponse<'a> {
  type Inner = ConfigurationResponse<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ConfigurationResponse<'a> {
  pub const VT_ERROR: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ConfigurationResponse { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ConfigurationResponseArgs<'args>
  ) -> flatbuffers::WIPOffset<ConfigurationResponse<'bldr>> {
    let mut builder = ConfigurationResponseBuilder::new(_fbb);
    if let Some(x) = args.error { builder.add_error(x); }
    builder.finish()
  }


  #[inline]
  pub fn error(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ConfigurationResponse::VT_ERROR, None)}
  }
}

impl flatbuffers::Verifiable for ConfigurationResponse<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("error", Self::VT_ERROR, false)?
     .finish();
    Ok(())
  }
}
pub struct ConfigurationResponseArgs<'a> {
    pub error: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ConfigurationResponseArgs<'a> {
  #[inline]
  fn default() -> Self {
    ConfigurationResponseArgs {
      error: None,
    }
  }
}

pub struct ConfigurationResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ConfigurationResponseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_error(&mut self, error: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ConfigurationResponse::VT_ERROR, error);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ConfigurationResponseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ConfigurationResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ConfigurationResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ConfigurationResponse<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ConfigurationResponse");
      ds.field("error", &self.error());
      ds.finish()
  }
}
pub enum DataRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DataRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DataRequest<'a> {
  type Inner = DataRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DataRequest<'a> {
  pub const VT_START_MAIN: flatbuffers::VOffsetT = 4;
  pub const VT_START_ALT: flatbuffers::VOffsetT = 6;
  pub const VT_DATA_WRITE: flatbuffers::VOffsetT = 8;
  pub const VT_BYTES_READ: flatbuffers::VOffsetT = 10;
  pub const VT_STOP_MAIN: flatbuffers::VOffsetT = 12;
  pub const VT_STOP_ALT: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DataRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DataRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<DataRequest<'bldr>> {
    let mut builder = DataRequestBuilder::new(_fbb);
    if let Some(x) = args.data_write { builder.add_data_write(x); }
    builder.add_bytes_read(args.bytes_read);
    builder.add_stop_alt(args.stop_alt);
    builder.add_stop_main(args.stop_main);
    builder.add_start_alt(args.start_alt);
    builder.add_start_main(args.start_main);
    builder.finish()
  }


  #[inline]
  pub fn start_main(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DataRequest::VT_START_MAIN, Some(false)).unwrap()}
  }
  #[inline]
  pub fn start_alt(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DataRequest::VT_START_ALT, Some(false)).unwrap()}
  }
  #[inline]
  pub fn data_write(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(DataRequest::VT_DATA_WRITE, None)}
  }
  #[inline]
  pub fn bytes_read(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(DataRequest::VT_BYTES_READ, Some(0)).unwrap()}
  }
  #[inline]
  pub fn stop_main(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DataRequest::VT_STOP_MAIN, Some(false)).unwrap()}
  }
  #[inline]
  pub fn stop_alt(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DataRequest::VT_STOP_ALT, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for DataRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("start_main", Self::VT_START_MAIN, false)?
     .visit_field::<bool>("start_alt", Self::VT_START_ALT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("data_write", Self::VT_DATA_WRITE, false)?
     .visit_field::<u16>("bytes_read", Self::VT_BYTES_READ, false)?
     .visit_field::<bool>("stop_main", Self::VT_STOP_MAIN, false)?
     .visit_field::<bool>("stop_alt", Self::VT_STOP_ALT, false)?
     .finish();
    Ok(())
  }
}
pub struct DataRequestArgs<'a> {
    pub start_main: bool,
    pub start_alt: bool,
    pub data_write: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub bytes_read: u16,
    pub stop_main: bool,
    pub stop_alt: bool,
}
impl<'a> Default for DataRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    DataRequestArgs {
      start_main: false,
      start_alt: false,
      data_write: None,
      bytes_read: 0,
      stop_main: false,
      stop_alt: false,
    }
  }
}

pub struct DataRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DataRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_start_main(&mut self, start_main: bool) {
    self.fbb_.push_slot::<bool>(DataRequest::VT_START_MAIN, start_main, false);
  }
  #[inline]
  pub fn add_start_alt(&mut self, start_alt: bool) {
    self.fbb_.push_slot::<bool>(DataRequest::VT_START_ALT, start_alt, false);
  }
  #[inline]
  pub fn add_data_write(&mut self, data_write: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataRequest::VT_DATA_WRITE, data_write);
  }
  #[inline]
  pub fn add_bytes_read(&mut self, bytes_read: u16) {
    self.fbb_.push_slot::<u16>(DataRequest::VT_BYTES_READ, bytes_read, 0);
  }
  #[inline]
  pub fn add_stop_main(&mut self, stop_main: bool) {
    self.fbb_.push_slot::<bool>(DataRequest::VT_STOP_MAIN, stop_main, false);
  }
  #[inline]
  pub fn add_stop_alt(&mut self, stop_alt: bool) {
    self.fbb_.push_slot::<bool>(DataRequest::VT_STOP_ALT, stop_alt, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DataRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DataRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DataRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DataRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DataRequest");
      ds.field("start_main", &self.start_main());
      ds.field("start_alt", &self.start_alt());
      ds.field("data_write", &self.data_write());
      ds.field("bytes_read", &self.bytes_read());
      ds.field("stop_main", &self.stop_main());
      ds.field("stop_alt", &self.stop_alt());
      ds.finish()
  }
}
pub enum DataResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DataResponse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DataResponse<'a> {
  type Inner = DataResponse<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DataResponse<'a> {
  pub const VT_ERROR: flatbuffers::VOffsetT = 4;
  pub const VT_DATA_READ: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DataResponse { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DataResponseArgs<'args>
  ) -> flatbuffers::WIPOffset<DataResponse<'bldr>> {
    let mut builder = DataResponseBuilder::new(_fbb);
    if let Some(x) = args.data_read { builder.add_data_read(x); }
    if let Some(x) = args.error { builder.add_error(x); }
    builder.finish()
  }


  #[inline]
  pub fn error(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DataResponse::VT_ERROR, None)}
  }
  #[inline]
  pub fn data_read(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(DataResponse::VT_DATA_READ, None)}
  }
}

impl flatbuffers::Verifiable for DataResponse<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("error", Self::VT_ERROR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("data_read", Self::VT_DATA_READ, false)?
     .finish();
    Ok(())
  }
}
pub struct DataResponseArgs<'a> {
    pub error: Option<flatbuffers::WIPOffset<&'a str>>,
    pub data_read: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for DataResponseArgs<'a> {
  #[inline]
  fn default() -> Self {
    DataResponseArgs {
      error: None,
      data_read: None,
    }
  }
}

pub struct DataResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DataResponseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_error(&mut self, error: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataResponse::VT_ERROR, error);
  }
  #[inline]
  pub fn add_data_read(&mut self, data_read: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataResponse::VT_DATA_READ, data_read);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DataResponseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DataResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DataResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DataResponse<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DataResponse");
      ds.field("error", &self.error());
      ds.field("data_read", &self.data_read());
      ds.finish()
  }
}
pub enum RequestPacketOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RequestPacket<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RequestPacket<'a> {
  type Inner = RequestPacket<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RequestPacket<'a> {
  pub const VT_VERSION_MAJOR: flatbuffers::VOffsetT = 4;
  pub const VT_VERSION_MINOR: flatbuffers::VOffsetT = 6;
  pub const VT_CONTENTS_TYPE: flatbuffers::VOffsetT = 8;
  pub const VT_CONTENTS: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RequestPacket { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RequestPacketArgs
  ) -> flatbuffers::WIPOffset<RequestPacket<'bldr>> {
    let mut builder = RequestPacketBuilder::new(_fbb);
    if let Some(x) = args.contents { builder.add_contents(x); }
    builder.add_contents_type(args.contents_type);
    builder.add_version_minor(args.version_minor);
    builder.add_version_major(args.version_major);
    builder.finish()
  }


  #[inline]
  pub fn version_major(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(RequestPacket::VT_VERSION_MAJOR, Some(0)).unwrap()}
  }
  #[inline]
  pub fn version_minor(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(RequestPacket::VT_VERSION_MINOR, Some(1)).unwrap()}
  }
  #[inline]
  pub fn contents_type(&self) -> RequestPacketContents {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<RequestPacketContents>(RequestPacket::VT_CONTENTS_TYPE, Some(RequestPacketContents::NONE)).unwrap()}
  }
  #[inline]
  pub fn contents(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(RequestPacket::VT_CONTENTS, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn contents_as_status_request(&self) -> Option<StatusRequest<'a>> {
    if self.contents_type() == RequestPacketContents::StatusRequest {
      self.contents().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { StatusRequest::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn contents_as_configuration_request(&self) -> Option<ConfigurationRequest<'a>> {
    if self.contents_type() == RequestPacketContents::ConfigurationRequest {
      self.contents().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { ConfigurationRequest::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn contents_as_data_request(&self) -> Option<DataRequest<'a>> {
    if self.contents_type() == RequestPacketContents::DataRequest {
      self.contents().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { DataRequest::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for RequestPacket<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("version_major", Self::VT_VERSION_MAJOR, false)?
     .visit_field::<u8>("version_minor", Self::VT_VERSION_MINOR, false)?
     .visit_union::<RequestPacketContents, _>("contents_type", Self::VT_CONTENTS_TYPE, "contents", Self::VT_CONTENTS, false, |key, v, pos| {
        match key {
          RequestPacketContents::StatusRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StatusRequest>>("RequestPacketContents::StatusRequest", pos),
          RequestPacketContents::ConfigurationRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConfigurationRequest>>("RequestPacketContents::ConfigurationRequest", pos),
          RequestPacketContents::DataRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DataRequest>>("RequestPacketContents::DataRequest", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct RequestPacketArgs {
    pub version_major: u8,
    pub version_minor: u8,
    pub contents_type: RequestPacketContents,
    pub contents: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for RequestPacketArgs {
  #[inline]
  fn default() -> Self {
    RequestPacketArgs {
      version_major: 0,
      version_minor: 1,
      contents_type: RequestPacketContents::NONE,
      contents: None,
    }
  }
}

pub struct RequestPacketBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RequestPacketBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_version_major(&mut self, version_major: u8) {
    self.fbb_.push_slot::<u8>(RequestPacket::VT_VERSION_MAJOR, version_major, 0);
  }
  #[inline]
  pub fn add_version_minor(&mut self, version_minor: u8) {
    self.fbb_.push_slot::<u8>(RequestPacket::VT_VERSION_MINOR, version_minor, 1);
  }
  #[inline]
  pub fn add_contents_type(&mut self, contents_type: RequestPacketContents) {
    self.fbb_.push_slot::<RequestPacketContents>(RequestPacket::VT_CONTENTS_TYPE, contents_type, RequestPacketContents::NONE);
  }
  #[inline]
  pub fn add_contents(&mut self, contents: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RequestPacket::VT_CONTENTS, contents);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RequestPacketBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RequestPacketBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RequestPacket<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RequestPacket<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RequestPacket");
      ds.field("version_major", &self.version_major());
      ds.field("version_minor", &self.version_minor());
      ds.field("contents_type", &self.contents_type());
      match self.contents_type() {
        RequestPacketContents::StatusRequest => {
          if let Some(x) = self.contents_as_status_request() {
            ds.field("contents", &x)
          } else {
            ds.field("contents", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RequestPacketContents::ConfigurationRequest => {
          if let Some(x) = self.contents_as_configuration_request() {
            ds.field("contents", &x)
          } else {
            ds.field("contents", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RequestPacketContents::DataRequest => {
          if let Some(x) = self.contents_as_data_request() {
            ds.field("contents", &x)
          } else {
            ds.field("contents", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("contents", &x)
        },
      };
      ds.finish()
  }
}
pub enum ErrorResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ErrorResponse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ErrorResponse<'a> {
  type Inner = ErrorResponse<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ErrorResponse<'a> {
  pub const VT_ERROR: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ErrorResponse { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ErrorResponseArgs<'args>
  ) -> flatbuffers::WIPOffset<ErrorResponse<'bldr>> {
    let mut builder = ErrorResponseBuilder::new(_fbb);
    if let Some(x) = args.error { builder.add_error(x); }
    builder.finish()
  }


  #[inline]
  pub fn error(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ErrorResponse::VT_ERROR, None)}
  }
}

impl flatbuffers::Verifiable for ErrorResponse<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("error", Self::VT_ERROR, false)?
     .finish();
    Ok(())
  }
}
pub struct ErrorResponseArgs<'a> {
    pub error: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ErrorResponseArgs<'a> {
  #[inline]
  fn default() -> Self {
    ErrorResponseArgs {
      error: None,
    }
  }
}

pub struct ErrorResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ErrorResponseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_error(&mut self, error: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ErrorResponse::VT_ERROR, error);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ErrorResponseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ErrorResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ErrorResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ErrorResponse<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ErrorResponse");
      ds.field("error", &self.error());
      ds.finish()
  }
}
pub enum ResponsePacketOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ResponsePacket<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ResponsePacket<'a> {
  type Inner = ResponsePacket<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ResponsePacket<'a> {
  pub const VT_VERSION_MAJOR: flatbuffers::VOffsetT = 4;
  pub const VT_VERSION_MINOR: flatbuffers::VOffsetT = 6;
  pub const VT_CONTENTS_TYPE: flatbuffers::VOffsetT = 8;
  pub const VT_CONTENTS: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ResponsePacket { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ResponsePacketArgs
  ) -> flatbuffers::WIPOffset<ResponsePacket<'bldr>> {
    let mut builder = ResponsePacketBuilder::new(_fbb);
    if let Some(x) = args.contents { builder.add_contents(x); }
    builder.add_contents_type(args.contents_type);
    builder.add_version_minor(args.version_minor);
    builder.add_version_major(args.version_major);
    builder.finish()
  }


  #[inline]
  pub fn version_major(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(ResponsePacket::VT_VERSION_MAJOR, Some(0)).unwrap()}
  }
  #[inline]
  pub fn version_minor(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(ResponsePacket::VT_VERSION_MINOR, Some(1)).unwrap()}
  }
  #[inline]
  pub fn contents_type(&self) -> ResponsePacketContents {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ResponsePacketContents>(ResponsePacket::VT_CONTENTS_TYPE, Some(ResponsePacketContents::NONE)).unwrap()}
  }
  #[inline]
  pub fn contents(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(ResponsePacket::VT_CONTENTS, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn contents_as_error_response(&self) -> Option<ErrorResponse<'a>> {
    if self.contents_type() == ResponsePacketContents::ErrorResponse {
      self.contents().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { ErrorResponse::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn contents_as_status_response(&self) -> Option<StatusResponse<'a>> {
    if self.contents_type() == ResponsePacketContents::StatusResponse {
      self.contents().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { StatusResponse::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn contents_as_configuration_response(&self) -> Option<ConfigurationResponse<'a>> {
    if self.contents_type() == ResponsePacketContents::ConfigurationResponse {
      self.contents().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { ConfigurationResponse::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn contents_as_data_response(&self) -> Option<DataResponse<'a>> {
    if self.contents_type() == ResponsePacketContents::DataResponse {
      self.contents().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { DataResponse::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for ResponsePacket<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("version_major", Self::VT_VERSION_MAJOR, false)?
     .visit_field::<u8>("version_minor", Self::VT_VERSION_MINOR, false)?
     .visit_union::<ResponsePacketContents, _>("contents_type", Self::VT_CONTENTS_TYPE, "contents", Self::VT_CONTENTS, false, |key, v, pos| {
        match key {
          ResponsePacketContents::ErrorResponse => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ErrorResponse>>("ResponsePacketContents::ErrorResponse", pos),
          ResponsePacketContents::StatusResponse => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StatusResponse>>("ResponsePacketContents::StatusResponse", pos),
          ResponsePacketContents::ConfigurationResponse => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConfigurationResponse>>("ResponsePacketContents::ConfigurationResponse", pos),
          ResponsePacketContents::DataResponse => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DataResponse>>("ResponsePacketContents::DataResponse", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct ResponsePacketArgs {
    pub version_major: u8,
    pub version_minor: u8,
    pub contents_type: ResponsePacketContents,
    pub contents: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for ResponsePacketArgs {
  #[inline]
  fn default() -> Self {
    ResponsePacketArgs {
      version_major: 0,
      version_minor: 1,
      contents_type: ResponsePacketContents::NONE,
      contents: None,
    }
  }
}

pub struct ResponsePacketBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ResponsePacketBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_version_major(&mut self, version_major: u8) {
    self.fbb_.push_slot::<u8>(ResponsePacket::VT_VERSION_MAJOR, version_major, 0);
  }
  #[inline]
  pub fn add_version_minor(&mut self, version_minor: u8) {
    self.fbb_.push_slot::<u8>(ResponsePacket::VT_VERSION_MINOR, version_minor, 1);
  }
  #[inline]
  pub fn add_contents_type(&mut self, contents_type: ResponsePacketContents) {
    self.fbb_.push_slot::<ResponsePacketContents>(ResponsePacket::VT_CONTENTS_TYPE, contents_type, ResponsePacketContents::NONE);
  }
  #[inline]
  pub fn add_contents(&mut self, contents: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ResponsePacket::VT_CONTENTS, contents);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ResponsePacketBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ResponsePacketBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ResponsePacket<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ResponsePacket<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ResponsePacket");
      ds.field("version_major", &self.version_major());
      ds.field("version_minor", &self.version_minor());
      ds.field("contents_type", &self.contents_type());
      match self.contents_type() {
        ResponsePacketContents::ErrorResponse => {
          if let Some(x) = self.contents_as_error_response() {
            ds.field("contents", &x)
          } else {
            ds.field("contents", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ResponsePacketContents::StatusResponse => {
          if let Some(x) = self.contents_as_status_response() {
            ds.field("contents", &x)
          } else {
            ds.field("contents", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ResponsePacketContents::ConfigurationResponse => {
          if let Some(x) = self.contents_as_configuration_response() {
            ds.field("contents", &x)
          } else {
            ds.field("contents", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ResponsePacketContents::DataResponse => {
          if let Some(x) = self.contents_as_data_response() {
            ds.field("contents", &x)
          } else {
            ds.field("contents", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("contents", &x)
        },
      };
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `ResponsePacket`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_response_packet_unchecked`.
pub fn root_as_response_packet(buf: &[u8]) -> Result<ResponsePacket, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<ResponsePacket>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `ResponsePacket` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_response_packet_unchecked`.
pub fn size_prefixed_root_as_response_packet(buf: &[u8]) -> Result<ResponsePacket, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<ResponsePacket>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `ResponsePacket` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_response_packet_unchecked`.
pub fn root_as_response_packet_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<ResponsePacket<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<ResponsePacket<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `ResponsePacket` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_response_packet_unchecked`.
pub fn size_prefixed_root_as_response_packet_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<ResponsePacket<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<ResponsePacket<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a ResponsePacket and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `ResponsePacket`.
pub unsafe fn root_as_response_packet_unchecked(buf: &[u8]) -> ResponsePacket {
  flatbuffers::root_unchecked::<ResponsePacket>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed ResponsePacket and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `ResponsePacket`.
pub unsafe fn size_prefixed_root_as_response_packet_unchecked(buf: &[u8]) -> ResponsePacket {
  flatbuffers::size_prefixed_root_unchecked::<ResponsePacket>(buf)
}
#[inline]
pub fn finish_response_packet_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<ResponsePacket<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_response_packet_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<ResponsePacket<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod bpio

